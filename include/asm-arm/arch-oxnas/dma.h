/*
 * linux/include/asm-arm/arch-oxnas/dma.h
 *
 * Copyright (C) 2005 Oxford Semiconductor Ltd
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * We have a generic DMAC that is a two port, memory to memory design, supporting
 * multiple channels, each of which can transfer between any pair of memory
 * regions. This DMAC architecture does not sit well with the std. ARM DMA
 * architecture, thus we define a custom way of acquiring and operating on the
 * available channels of the DMAC
 */

#ifndef __ASM_ARCH_DMA_H
#define __ASM_ARCH_DMA_H

#include <asm/scatterlist.h>
#include <asm/semaphore.h>
#include <linux/ata.h>
#include <linux/interrupt.h>
#include <linux/spinlock.h>

/* All memory DMAable */
#define MAX_DMA_ADDRESS (~0UL)

/* Do not want to use the std. ARM DMA architecure */
#define MAX_DMA_CHANNELS 0

#define MAX_OXNAS_DMA_CHANNELS 5

#define MAX_OXNAS_DMA_TRANSFER_LENGTH ((1 << 21) - 1)

#ifdef CONFIG_OXNAS_VERSION_0X800
// Need to set this (unused) high order address bit in the start address of DMA
// transfers in order for checksum calculation to be performed
#define OXNAS_DMA_CSUM_ENABLE_ADR_BIT 28
#endif // CONFIG_OXNAS_VERSION_0X800

//#define OXNAS_DMA_TEST
//#define OXNAS_DMA_TEST_ITERATIONS 1
//#define OXNAS_DMA_SG_TEST
//#define OXNAS_DMA_SG_TEST_2
//#define OXNAS_DMA_SG_TEST_ITERATIONS 1
//#define OXNAS_DMA_SG_TEST2_ITERATIONS 1
//#define OXNAS_DMA_SG_TEST_DUMP_BUFFERS
//#define OXNAS_DMA_SG_TEST_DUMP_DESCRIPTORS
//#define OXNAS_DMA_TEST_AFTER_SG_ITERATIONS 0
//#define OXNAS_DMA_OVERALL_TEST_LOOPS 1

// All other error codes are generated by the SG engine - refer to its
// documentation for details
typedef enum oxnas_dma_callback_status {
    OXNAS_DMA_ERROR_CODE_NONE
} oxnas_dma_callback_status_t;

typedef enum oxnas_dma_mode {
    OXNAS_DMA_MODE_FIXED,
    OXNAS_DMA_MODE_INC
} oxnas_dma_mode_t;

typedef enum oxnas_dma_direction {
    OXNAS_DMA_TO_DEVICE,
    OXNAS_DMA_FROM_DEVICE
} oxnas_dma_direction_t;

struct oxnas_dma_channel;
typedef struct oxnas_dma_channel oxnas_dma_channel_t;

#define OXNAS_DMA_CHANNEL_NUL ((oxnas_dma_channel_t*)0)

typedef void* oxnas_callback_arg_t;

#define OXNAS_DMA_CALLBACK_ARG_NUL ((oxnas_callback_arg_t)0)

typedef void (*oxnas_dma_callback_t)(oxnas_dma_channel_t*, oxnas_callback_arg_t, oxnas_dma_callback_status_t, u16 checksum, int interrupt_count);

#define OXNAS_DMA_CALLBACK_NUL ((oxnas_dma_callback_t)0)

typedef enum oxnas_dma_eot_type {
    OXNAS_DMA_EOT_NONE,
    OXNAS_DMA_EOT_ALL,
    OXNAS_DMA_EOT_FINAL
} oxnas_dma_eot_type_t;

// Will be exchanged with SG DMA controller
typedef struct oxnas_dma_sg_entry {
    dma_addr_t                 addr_;   // The physical address of the buffer described by this descriptor
    unsigned long              length_; // The length of the buffer described by this descriptor
    dma_addr_t                 p_next_; // The physical address of the next descriptor
    struct oxnas_dma_sg_entry *v_next_; // The virtual address of the next descriptor
    dma_addr_t                 paddr_;  // The physical address of this descriptor
    struct oxnas_dma_sg_entry *next_;   // To allow insertion into single-linked list
} __attribute ((aligned(4),packed)) oxnas_dma_sg_entry_t;

// Will be exchanged with SG DMA controller
typedef struct oxnas_dma_sg_info {
    unsigned long         qualifer_;
    unsigned long         control_;
    dma_addr_t            p_srcEntries_; // The physical address of the first source SG descriptor
    dma_addr_t            p_dstEntries_; // The physical address of the first destination SG descriptor
    oxnas_dma_sg_entry_t *v_srcEntries_; // The virtual address of the first source SG descriptor
    oxnas_dma_sg_entry_t *v_dstEntries_; // The virtual address of the first destination SG descriptor
} __attribute ((aligned(4),packed)) oxnas_dma_sg_info_t;

struct oxnas_dma_channel {
    unsigned                     channel_number_;
    oxnas_dma_callback_t         notification_callback_;
    oxnas_callback_arg_t         notification_arg_;
    dma_addr_t                   p_sg_info_;    // Physical address of sg_info structure
    oxnas_dma_sg_info_t         *v_sg_info_;    // Virtual address of sg_info structure
    oxnas_dma_callback_status_t  error_code_;
#ifdef CONFIG_OXNAS_VERSION_0X800
    int                          checksumming_;
    u16                          checksum_;
#endif // CONFIG_OXNAS_VERSION_0X800
    unsigned                     rps_interrupt_;
    struct oxnas_dma_channel    *next_;
    struct semaphore             default_semaphore_;
    atomic_t                     interrupt_count_;
    atomic_t                     active_count_;
	int							  auto_sg_entries_;
};

typedef struct oxnas_dma_controller {
    oxnas_dma_channel_t        channels_[MAX_OXNAS_DMA_CHANNELS];
    unsigned                   numberOfChannels_;
    int                        version_;
    atomic_t                   run_bh_;
    spinlock_t                 spinlock_;
    struct                     tasklet_struct tasklet_;
    dma_addr_t                 p_sg_infos_;     // Physical address of the array of sg_info structures
    oxnas_dma_sg_info_t       *v_sg_infos_;     // Virtual address of the array of sg_info structures
    struct semaphore           csum_engine_sem_;
    spinlock_t                 alloc_spinlock_;  // Sync. for SG management
    spinlock_t                 channel_alloc_spinlock_;  // Sync. for channel management
    oxnas_dma_sg_entry_t      *sg_entry_head_;  // Pointer to head of free list for oxnas_dma_sg_entry_t objects
    struct semaphore           sg_entry_sem_;
    unsigned                   sg_entry_available_;
    oxnas_dma_channel_t       *channel_head_;
    struct semaphore           channel_sem_;
} oxnas_dma_controller_t;

typedef struct oxnas_dma_device_settings {
    unsigned long address_;
    unsigned      fifo_size_;   // Chained transfers must take account of FIFO offset at end of previous transfer
    unsigned char dreq_;
    unsigned      read_eot_policy_:2;
    unsigned      write_eot_policy_:2;
    unsigned      bus_:1;
    unsigned      width_:2;
    unsigned      transfer_mode_:1;
    unsigned      address_mode_:1;
    unsigned      address_really_fixed_:1;
} oxnas_dma_device_settings_t;

/* Pre-defined settings for known DMA devices */
extern oxnas_dma_device_settings_t oxnas_pata_dma_settings;
extern oxnas_dma_device_settings_t oxnas_sata_dma_settings;
extern oxnas_dma_device_settings_t oxnas_dpe_rx_dma_settings;
extern oxnas_dma_device_settings_t oxnas_dpe_tx_dma_settings;

extern void oxnas_dma_init(void);

extern void oxnas_dma_shutdown(void);

extern oxnas_dma_channel_t* oxnas_dma_request(int block);

extern void oxnas_dma_free(oxnas_dma_channel_t*);

extern int oxnas_dma_is_active(oxnas_dma_channel_t*);

extern int oxnas_dma_raw_isactive(oxnas_dma_channel_t*);

extern int oxnas_dma_raw_sg_isactive(oxnas_dma_channel_t*);

extern int oxnas_dma_get_raw_direction(oxnas_dma_channel_t*);

/**
 * @param do_checksum An int indicating that the checksum engine is required
 *                    and causing the OXNAS_DMA_CSUM_ENABLE_ADR_BIT to be set
 *                    automatically in the passed src and dst start addresses
 * @return An int which is zero on success. Non-zero will returned if the length
 *         exceeds that allowed by the hardware
 */
extern int oxnas_dma_set(
    oxnas_dma_channel_t *channel,
    unsigned char       *src_adr,   // Physical address
    unsigned long        length,
    unsigned char       *dst_adr,   // Physical address
    oxnas_dma_mode_t     src_mode,
    oxnas_dma_mode_t     dst_mode,
    int                  do_checksum,
    int                  paused);

/**
 * @return An int which is zero on success. Non-zero will returned if the length
 *         exceeds that allowed by the hardware
 */
extern int oxnas_dma_device_set(
    oxnas_dma_channel_t         *channel,
    oxnas_dma_direction_t        direction,
    unsigned char               *mem_adr,   // Physical address
    unsigned long                length,
    oxnas_dma_device_settings_t *device_settings,
    oxnas_dma_mode_t             mem_mode,
    int                          paused);

/**
 * @return An int which is zero on success. Non-zero will returned if the length
 *         exceeds that allowed by the hardware
 */
extern int oxnas_dma_device_pair_set(
    oxnas_dma_channel_t         *channel,
    unsigned long                length,
    oxnas_dma_device_settings_t *src_device_settings,
    oxnas_dma_device_settings_t *dst_device_settings,
    int                          paused);

/**
 * @param do_checksum An int indicating that the checksum engine is required
 *                    for this SG transfer. For the individual SG transfer
 *                    components to contribute to the checksum result, their
 *                    start addresses contained within the scatterlist
 *                    structures must have the OXNAS_DMA_CSUM_ENABLE_ADR_BIT
 *                    bit set
 *
 *  NB This function does not have an error return value, but if it is passed
 *     a transfer segment longer than the maximum allowed by the hardware, that
 *     entry will be zeroed in the SG descriptor list and a kernel warning
 *     message generated
 */
extern int oxnas_dma_set_sg(
    oxnas_dma_channel_t* channel,
    struct scatterlist*  src_sg,
    unsigned             src_sg_count,
    struct scatterlist*  dst_sg,
    unsigned             dst_sg_count,
    oxnas_dma_mode_t     src_mode,
    oxnas_dma_mode_t     dst_mode,
    int                  do_checksum,
	int                  in_atomic);

/**
 *  NB This function does not have an error return value, but if it is passed
 *     a transfer segment longer than the maximum allowed by the hardware, that
 *     entry will be zeroed in the SG descriptor list and a kernel warning
 *     message generated
 */
extern int oxnas_dma_device_set_sg(
    oxnas_dma_channel_t*         channel,
    oxnas_dma_direction_t        direction,
    struct scatterlist*          mem_sg,
    unsigned                     mem_sg_count,
    oxnas_dma_device_settings_t* device_settings,
    oxnas_dma_mode_t             mem_mode,
	int                          in_atomic);

extern int oxnas_dma_device_set_prd(
    oxnas_dma_channel_t			 *channel,
    oxnas_dma_direction_t        direction,
	struct ata_prd				 *prd,
    oxnas_dma_device_settings_t *device_settings,
    oxnas_dma_mode_t             mem_mode,
	oxnas_dma_sg_entry_t		 *sg_entries);

/**
 * The callback function should complete quickly and must not sleep
 */
extern void oxnas_dma_set_callback(
    oxnas_dma_channel_t*,
    oxnas_dma_callback_t callback,
    oxnas_callback_arg_t callback_arg);

extern void oxnas_dma_abort(oxnas_dma_channel_t*, int in_atomic);

extern void oxnas_dma_start(oxnas_dma_channel_t*);

extern void oxnas_dma_dump_registers(void);

extern void oxnas_dma_dump_registers_single(int channel_number);

extern int oxnas_dma_alloc_sg_entries(oxnas_dma_sg_entry_t** entries, unsigned required, int in_atomic);

extern void oxnas_dma_free_sg_entries(oxnas_dma_sg_entry_t* entries);
#endif // __ASM_ARCH_DMA_H
