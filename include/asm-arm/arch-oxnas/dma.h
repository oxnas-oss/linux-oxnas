/*
 * linux/include/asm-arm/arch-oxnas/dma.h
 *
 * Copyright (C) 2005 Oxford Semiconductor Ltd
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * We have a generic DMAC that is a two port, memory to memory design, supporting
 * multiple channels, each of which can transfer between any pair of memory
 * regions. This DMAC architecture does not sit well with the std. ARM DMA
 * architecture, thus we define a custom way of acquiring and operating on the
 * available channels of the DMAC
 */

#ifndef __ASM_ARCH_DMA_H
#define __ASM_ARCH_DMA_H

#include <asm/scatterlist.h>
#include <asm/semaphore.h>
#include <linux/ata.h>
#include <linux/interrupt.h>
#include <linux/spinlock.h>
//#include <linux/workqueue.h>

/* All memory DMAable */
#define MAX_DMA_ADDRESS (~0UL)

/* Do not want to use the std. ARM DMA architecure */
#define MAX_DMA_CHANNELS 0

#define MAX_OXNAS_DMA_CHANNELS 5

#define MAX_OXNAS_DMA_TRANSGER_LENGTH ((1 << 21) - 1)

// Need to set this (unused) high order address bit in the start address of DMA
// transfers in order for checksum calculation to be performed
#define OXNAS_DMA_CSUM_ENABLE_ADR_BIT 28

//#define OXNAS_USE_LEON_SG_DMA

#define OXNAS_DMA_HAVE_HW_SG
#define OXNAS_DMA_NUM_SG_CONTROLLERS (MAX_OXNAS_DMA_CHANNELS)

#if defined(OXNAS_USE_LEON_SG_DMA) && defined(OXNAS_DMA_HAVE_HW_SG)
#error "Have LEON and H/W SG DMA defined"
#endif

//#define OXNAS_DMA_TEST
//#define OXNAS_DMA_TEST_ITERATIONS 1
//#define OXNAS_DMA_SG_TEST
//#define OXNAS_DMA_SG_TEST_2
//#define OXNAS_DMA_SG_TEST_ITERATIONS 1
//#define OXNAS_DMA_SG_TEST2_ITERATIONS 1
//#define OXNAS_DMA_SG_TEST_DUMP_BUFFERS
//#define OXNAS_DMA_SG_TEST_DUMP_DESCRIPTORS
//#define OXNAS_DMA_TEST_AFTER_SG_ITERATIONS 0
//#define OXNAS_DMA_OVERALL_TEST_LOOPS 1

// All other error codes are generated by the SG engine - refer to its
// documentation for details
typedef enum oxnas_dma_callback_status {
    OXNAS_DMA_ERROR_CODE_NONE
} oxnas_dma_callback_status_t;

typedef enum oxnas_dma_mode {
    OXNAS_DMA_MODE_FIXED,
    OXNAS_DMA_MODE_INC
} oxnas_dma_mode_t;

typedef enum oxnas_dma_direction {
    OXNAS_DMA_TO_DEVICE,
    OXNAS_DMA_FROM_DEVICE
} oxnas_dma_direction_t;

struct oxnas_dma_channel;
typedef struct oxnas_dma_channel oxnas_dma_channel_t;

#define OXNAS_DMA_CHANNEL_NUL ((oxnas_dma_channel_t*)0)

typedef void* oxnas_callback_arg_t;

#define OXNAS_DMA_CALLBACK_ARG_NUL ((oxnas_callback_arg_t)0)

typedef void (*oxnas_dma_callback_t)(oxnas_dma_channel_t*, oxnas_callback_arg_t, oxnas_dma_callback_status_t, u16 checksum, int interrupt_count);

#define OXNAS_DMA_CALLBACK_NUL ((oxnas_dma_callback_t)0)

typedef enum oxnas_dma_eot_type {
    OXNAS_DMA_EOT_NONE,
    OXNAS_DMA_EOT_ALL,
    OXNAS_DMA_EOT_FINAL
} oxnas_dma_eot_type_t;

// Will be exchanged with SG DMA controller
typedef struct oxnas_dma_sg_entry {
    dma_addr_t                 addr_;   // The physical address of the buffer described by this descriptor
    unsigned long              length_; // The length of the buffer described by this descriptor
    dma_addr_t                 p_next_; // The physical address of the next descriptor
    struct oxnas_dma_sg_entry *v_next_; // The virtual address of the next descriptor
    dma_addr_t                 paddr_;  // The physical address of this descriptor
#ifdef CONFIG_DESCRIPTORS_IN_SRAM
    struct oxnas_dma_sg_entry *next_;   // To allow insertion into single-linked list
#endif // CONFIG_DESCRIPTORS_IN_SRAM
} __attribute ((packed)) oxnas_dma_sg_entry_t;

// Will be exchanged with SG DMA controller
typedef struct oxnas_dma_sg_info {
    unsigned long         qualifer_;
    unsigned long         control_;
#ifdef OXNAS_USE_LEON_SG_DMA
    unsigned short        srcEOT_;
    unsigned short        dstEOT_;
#endif // OXNAS_USE_LEON_SG_DMA
    dma_addr_t            p_srcEntries_; // The physical address of the first source SG descriptor
    dma_addr_t            p_dstEntries_; // The physical address of the first destination SG descriptor
    oxnas_dma_sg_entry_t *v_srcEntries_; // The virtual address of the first source SG descriptor
    oxnas_dma_sg_entry_t *v_dstEntries_; // The virtual address of the first destination SG descriptor
} __attribute ((packed)) oxnas_dma_sg_info_t;

#ifdef OXNAS_DMA_HAVE_HW_SG
typedef struct oxnas_dma_sg_controller {
    unsigned                        number_;
    oxnas_dma_channel_t            *channel_;
    struct oxnas_dma_sg_controller *next_;
} oxnas_dma_sg_controller_t;
#endif // OXNAS_DMA_HAVE_HW_SG

struct oxnas_dma_channel {
    unsigned                     channel_number_;
    oxnas_dma_callback_t         notification_callback_;
    oxnas_callback_arg_t         notification_arg_;
    dma_addr_t                   p_sg_info_;    // Physical address of sg_info structure
    oxnas_dma_sg_info_t         *v_sg_info_;    // Virtual address of sg_info structure
    oxnas_dma_callback_status_t  error_code_;
    int                          checksumming_;
    u16                          checksum_;
#ifdef OXNAS_DMA_HAVE_HW_SG
    oxnas_dma_sg_controller_t   *sg_controller_;
#endif // OXNAS_DMA_HAVE_HW_SG
    unsigned                     rps_interrupt_;
    struct oxnas_dma_channel    *next_;
    struct semaphore             default_semaphore_;
    atomic_t                     interrupt_count_;
    atomic_t                     active_count_;
};

typedef struct oxnas_dma_controller {
    oxnas_dma_channel_t        channels_[MAX_OXNAS_DMA_CHANNELS];
    unsigned                   numberOfChannels_;
    int                        version_;
    atomic_t                   run_bh_;
    spinlock_t                 spinlock_;
    struct                     tasklet_struct tasklet_;
    dma_addr_t                 p_sg_infos_;     // Physical address of the array of sg_info structures
    oxnas_dma_sg_info_t       *v_sg_infos_;     // Virtual address of the array of sg_info structures
    struct semaphore           csum_engine_sem_;
    spinlock_t                 alloc_spinlock_;  // Sync. for resource management
#ifdef CONFIG_DESCRIPTORS_IN_SRAM
    oxnas_dma_sg_entry_t      *sg_entry_head_;  // Pointer to head of free list for oxnas_dma_sg_entry_t objects
    struct semaphore           sg_entry_sem_;
    unsigned                   sg_entry_available_;
#else // CONFIG_DESCRIPTORS_IN_SRAM
    struct dma_pool           *desc_dma_pool;
#endif // CONFIG_DESCRIPTORS_IN_SRAM
#ifdef OXNAS_DMA_HAVE_HW_SG
    spinlock_t                 sg_status_spinlock_;
    oxnas_dma_sg_controller_t  sg_controllers_[OXNAS_DMA_NUM_SG_CONTROLLERS];
#endif // OXNAS_DMA_HAVE_HW_SG
    oxnas_dma_channel_t       *channel_head_;
    struct semaphore           channel_sem_;
} oxnas_dma_controller_t;

typedef struct oxnas_dma_device_settings {
    unsigned long address_;
    unsigned      fifo_size_;   // Chained transfers must take account of FIFO offset at end of previous transfer
    unsigned char dreq_;
    unsigned      read_eot_policy_:2;
    unsigned      write_eot_policy_:2;
    unsigned      bus_:1;
    unsigned      width_:2;
    unsigned      transfer_mode_:1;
    unsigned      address_mode_:1;
    unsigned      address_really_fixed_:1;
} oxnas_dma_device_settings_t;

/* Pre-defined settings for known DMA devices */
extern oxnas_dma_device_settings_t oxnas_pata_dma_settings;
extern oxnas_dma_device_settings_t oxnas_sata_dma_settings;
extern oxnas_dma_device_settings_t oxnas_dpe_rx_dma_settings;
extern oxnas_dma_device_settings_t oxnas_dpe_tx_dma_settings;

extern void oxnas_dma_init(void);

extern void oxnas_dma_shutdown(void);

extern oxnas_dma_channel_t* oxnas_dma_request(int block);

extern void oxnas_dma_free(oxnas_dma_channel_t*);

extern int oxnas_dma_is_active(oxnas_dma_channel_t*);

extern int oxnas_dma_raw_isactive(oxnas_dma_channel_t*);

extern int oxnas_dma_raw_sg_isactive(oxnas_dma_channel_t*);

extern int oxnas_dma_get_raw_direction(oxnas_dma_channel_t*);

/**
 * @param do_checksum An int indicating that the checksum engine is required
 *                    and causing the OXNAS_DMA_CSUM_ENABLE_ADR_BIT to be set
 *                    automatically in the passed src and dst start addresses
 * @return An int which is zero on success. Non-zero will returned if the length
 *         exceeds that allowed by the hardware
 */
extern int oxnas_dma_set(
    oxnas_dma_channel_t *channel,
    unsigned char       *src_adr,   // Physical address
    unsigned long        length,
    unsigned char       *dst_adr,   // Physical address
    oxnas_dma_mode_t     src_mode,
    oxnas_dma_mode_t     dst_mode,
    int                  do_checksum,
    int                  paused);

/**
 * @return An int which is zero on success. Non-zero will returned if the length
 *         exceeds that allowed by the hardware
 */
extern int oxnas_dma_device_set(
    oxnas_dma_channel_t         *channel,
    oxnas_dma_direction_t        direction,
    unsigned char               *mem_adr,   // Physical address
    unsigned long                length,
    oxnas_dma_device_settings_t *device_settings,
    oxnas_dma_mode_t             mem_mode,
    int                          paused);

/**
 * @return An int which is zero on success. Non-zero will returned if the length
 *         exceeds that allowed by the hardware
 */
extern int oxnas_dma_device_pair_set(
    oxnas_dma_channel_t         *channel,
    unsigned long                length,
    oxnas_dma_device_settings_t *src_device_settings,
    oxnas_dma_device_settings_t *dst_device_settings,
    int                          paused);

/**
 * @param do_checksum An int indicating that the checksum engine is required
 *                    for this SG transfer. For the individual SG transfer
 *                    components to contribute to the checksum result, their
 *                    start addresses contained within the scatterlist
 *                    structures must have the OXNAS_DMA_CSUM_ENABLE_ADR_BIT
 *                    bit set
 *
 *  NB This function does not have an error return value, but if it is passed
 *     a transfer segment longer than the maximum allowed by the hardware, that
 *     entry will be zeroed in the SG descriptor list and a kernel warning
 *     message generated
 */
extern int oxnas_dma_set_sg(
    oxnas_dma_channel_t* channel,
    struct scatterlist*  src_sg,
    unsigned             src_sg_count,
    struct scatterlist*  dst_sg,
    unsigned             dst_sg_count,
    oxnas_dma_mode_t     src_mode,
    oxnas_dma_mode_t     dst_mode,
    int                  do_checksum);

/**
 *  NB This function does not have an error return value, but if it is passed
 *     a transfer segment longer than the maximum allowed by the hardware, that
 *     entry will be zeroed in the SG descriptor list and a kernel warning
 *     message generated
 */
extern int oxnas_dma_device_set_sg(
    oxnas_dma_channel_t*         channel,
    oxnas_dma_direction_t        direction,
    struct scatterlist*          mem_sg,
    unsigned                     mem_sg_count,
    oxnas_dma_device_settings_t* device_settings,
    oxnas_dma_mode_t             mem_mode);

extern int oxnas_dma_device_set_prd(
    oxnas_dma_channel_t			*channel,
    oxnas_dma_direction_t        direction,
	struct ata_prd				*prd,
    oxnas_dma_device_settings_t *device_settings,
    oxnas_dma_mode_t             mem_mode);

/**
 * The callback function should complete quickly and must not sleep
 */
extern void oxnas_dma_set_callback(
    oxnas_dma_channel_t*,
    oxnas_dma_callback_t callback,
    oxnas_callback_arg_t callback_arg);

extern void oxnas_dma_abort(oxnas_dma_channel_t*);

extern void oxnas_dma_start(oxnas_dma_channel_t*);

extern void oxnas_dma_dump_registers(void);

extern void oxnas_dma_dump_registers_single(int channel_number);

#endif // __ASM_ARCH_DMA_H
